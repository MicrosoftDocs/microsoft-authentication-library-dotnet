<Type Name="ConfidentialClientApplication" FullName="Microsoft.Identity.Client.ConfidentialClientApplication">
  <TypeSignature Language="C#" Value="public sealed class ConfidentialClientApplication : Microsoft.Identity.Client.ClientApplicationBase, Microsoft.Identity.Client.IByRefreshToken, Microsoft.Identity.Client.IByUsernameAndPassword, Microsoft.Identity.Client.IConfidentialClientApplication, Microsoft.Identity.Client.ILongRunningWebApi" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConfidentialClientApplication extends Microsoft.Identity.Client.ClientApplicationBase implements class Microsoft.Identity.Client.IApplicationBase, class Microsoft.Identity.Client.IByRefreshToken, class Microsoft.Identity.Client.IByUsernameAndPassword, class Microsoft.Identity.Client.IClientApplicationBase, class Microsoft.Identity.Client.IConfidentialClientApplication, class Microsoft.Identity.Client.ILongRunningWebApi" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Identity.Client.ConfidentialClientApplication" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConfidentialClientApplication&#xA;Inherits ClientApplicationBase&#xA;Implements IByRefreshToken, IByUsernameAndPassword, IConfidentialClientApplication, ILongRunningWebApi" />
  <TypeSignature Language="F#" Value="type ConfidentialClientApplication = class&#xA;    inherit ClientApplicationBase&#xA;    interface IConfidentialClientApplication&#xA;    interface IClientApplicationBase&#xA;    interface IApplicationBase&#xA;    interface IByRefreshToken&#xA;    interface ILongRunningWebApi&#xA;    interface IByUsernameAndPassword" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Identity.Client</AssemblyName>
    <AssemblyVersion>4.48.1.0</AssemblyVersion>
    <AssemblyVersion>4.49.1.0</AssemblyVersion>
    <AssemblyVersion>4.51.0.0</AssemblyVersion>
    <AssemblyVersion>4.52.0.0</AssemblyVersion>
    <AssemblyVersion>4.53.0.0</AssemblyVersion>
    <AssemblyVersion>4.54.0.0</AssemblyVersion>
    <AssemblyVersion>4.54.1.0</AssemblyVersion>
    <AssemblyVersion>4.55.0.0</AssemblyVersion>
    <AssemblyVersion>4.56.0.0</AssemblyVersion>
    <AssemblyVersion>4.57.0.0</AssemblyVersion>
    <AssemblyVersion>4.58.0.0</AssemblyVersion>
    <AssemblyVersion>4.58.1.0</AssemblyVersion>
    <AssemblyVersion>4.59.0.0</AssemblyVersion>
    <AssemblyVersion>4.60.0.0</AssemblyVersion>
    <AssemblyVersion>4.60.1.0</AssemblyVersion>
    <AssemblyVersion>4.60.2.0</AssemblyVersion>
    <AssemblyVersion>4.60.3.0</AssemblyVersion>
    <AssemblyVersion>4.61.0.0</AssemblyVersion>
    <AssemblyVersion>4.61.1.0</AssemblyVersion>
    <AssemblyVersion>4.61.3.0</AssemblyVersion>
    <AssemblyVersion>4.62.0.0</AssemblyVersion>
    <AssemblyVersion>4.63.0.0</AssemblyVersion>
    <AssemblyVersion>4.64.0.0</AssemblyVersion>
    <AssemblyVersion>4.64.1.0</AssemblyVersion>
    <AssemblyVersion>4.65.0.0</AssemblyVersion>
    <AssemblyVersion>4.66.0.0</AssemblyVersion>
    <AssemblyVersion>4.66.1.0</AssemblyVersion>
    <AssemblyVersion>4.66.2.0</AssemblyVersion>
    <AssemblyVersion>4.67.0.0</AssemblyVersion>
    <AssemblyVersion>4.67.1.0</AssemblyVersion>
    <AssemblyVersion>4.67.2.0</AssemblyVersion>
    <AssemblyVersion>4.68.0.0</AssemblyVersion>
    <AssemblyVersion>4.69.1.0</AssemblyVersion>
    <AssemblyVersion>4.70.0.0</AssemblyVersion>
    <AssemblyVersion>4.70.1.0</AssemblyVersion>
    <AssemblyVersion>4.70.2.0</AssemblyVersion>
    <AssemblyVersion>4.71.0.0</AssemblyVersion>
    <AssemblyVersion>4.71.1.0</AssemblyVersion>
    <AssemblyVersion>4.74.0.0</AssemblyVersion>
    <AssemblyVersion>4.74.1.0</AssemblyVersion>
    <AssemblyVersion>4.76.0.0</AssemblyVersion>
    <AssemblyVersion>4.77.0.0</AssemblyVersion>
    <AssemblyVersion>4.77.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.Identity.Client.ClientApplicationBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IApplicationBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IByRefreshToken</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IByUsernameAndPassword</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IClientApplicationBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IConfidentialClientApplication</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.ILongRunningWebApi</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
            Class to be used for confidential client applications (web apps, web APIs, and daemon applications).
            </summary>
    <remarks>
            Confidential client applications are typically applications which run on servers (web apps, web API, or even service/daemon applications).
            They are considered difficult to access, and therefore capable of keeping an application secret (hold configuration
            time secrets as these values would be difficult for end users to extract).
            A web app is the most common confidential client. The clientId is exposed through the web browser, but the secret is passed only in the back channel
            and never directly exposed. For details see https://aka.ms/msal-net-client-applications
            </remarks>
    <inheritdoc cref="T:Microsoft.Identity.Client.IConfidentialClientApplication" />
  </Docs>
  <Members>
    <Member MemberName="AcquireTokenByAuthorizationCode">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder AcquireTokenByAuthorizationCode (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string authorizationCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder AcquireTokenByAuthorizationCode(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string authorizationCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenByAuthorizationCode(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenByAuthorizationCode (scopes As IEnumerable(Of String), authorizationCode As String) As AcquireTokenByAuthorizationCodeParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenByAuthorizationCode : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder&#xA;override this.AcquireTokenByAuthorizationCode : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder" Usage="confidentialClientApplication.AcquireTokenByAuthorizationCode (scopes, authorizationCode)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenByAuthorizationCode(System.Collections.Generic.IEnumerable{System.String},System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="authorizationCode" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="authorizationCode">The authorization code received from the service authorization endpoint.</param>
        <summary>
            Acquires a security token from the authority configured in the app using the authorization code
            previously received from the STS.
            It uses the OAuth 2.0 authorization code flow (See https://aka.ms/msal-net-authorization-code).
            It's usually used in web apps (for instance ASP.NET / ASP.NET Core web apps) which sign-in users,
            and can request an authorization code.
            This method does not lookup the token cache, but stores the result in it, so it can be looked up
            using other methods such as <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)" />.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        <remarks>You can set optional parameters by chaining the builder with other .With methods.
            </remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenForClient">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder AcquireTokenForClient (System.Collections.Generic.IEnumerable&lt;string&gt; scopes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder AcquireTokenForClient(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenForClient (scopes As IEnumerable(Of String)) As AcquireTokenForClientParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenForClient : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder&#xA;override this.AcquireTokenForClient : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder" Usage="confidentialClientApplication.AcquireTokenForClient scopes" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="scopes">scopes requested to access a protected API. 
            For this flow (client credentials), the scopes of Microsoft APIs protected with AAD tokens are of the form "{ResourceIdUri/.default}". For example <c>https://management.azure.net/.default</c> or, for Microsoft
            Graph, <c>https://graph.microsoft.com/.default</c>. 
            The requested scopes are defined statically with the application registration in the portal, and cannot be overridden in the application.</param>
        <summary>
            Acquires a token from the authority configured in the app, for the confidential client itself (in the name of no user)
            using the client credentials flow. See https://aka.ms/msal-net-client-credentials.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        <remarks>You can also chain the following optional parameters:
            <see cref="M:Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder.WithForceRefresh(System.Boolean)" /><see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})" /></remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenInLongRunningProcess">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder AcquireTokenInLongRunningProcess (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string longRunningProcessSessionKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder AcquireTokenInLongRunningProcess(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string longRunningProcessSessionKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenInLongRunningProcess(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenInLongRunningProcess (scopes As IEnumerable(Of String), longRunningProcessSessionKey As String) As AcquireTokenOnBehalfOfParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenInLongRunningProcess : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder&#xA;override this.AcquireTokenInLongRunningProcess : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder" Usage="confidentialClientApplication.AcquireTokenInLongRunningProcess (scopes, longRunningProcessSessionKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.ILongRunningWebApi.AcquireTokenInLongRunningProcess(System.Collections.Generic.IEnumerable{System.String},System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="longRunningProcessSessionKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">To be added.</param>
        <param name="longRunningProcessSessionKey">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenOnBehalfOf">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder AcquireTokenOnBehalfOf (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, Microsoft.Identity.Client.UserAssertion userAssertion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder AcquireTokenOnBehalfOf(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, class Microsoft.Identity.Client.UserAssertion userAssertion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenOnBehalfOf(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenOnBehalfOf (scopes As IEnumerable(Of String), userAssertion As UserAssertion) As AcquireTokenOnBehalfOfParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenOnBehalfOf : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder&#xA;override this.AcquireTokenOnBehalfOf : seq&lt;string&gt; * Microsoft.Identity.Client.UserAssertion -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder" Usage="confidentialClientApplication.AcquireTokenOnBehalfOf (scopes, userAssertion)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenOnBehalfOf(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="userAssertion" Type="Microsoft.Identity.Client.UserAssertion" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="userAssertion">Instance of <see cref="T:Microsoft.Identity.Client.UserAssertion" /> containing credential information about
            the user on behalf of whom to get a token.</param>
        <summary>
            Acquires an access token for this application (usually a Web API) from the authority configured in the application,
            in order to access another downstream protected web API on behalf of a user using the OAuth 2.0 On-Behalf-Of flow.
            See https://aka.ms/msal-net-on-behalf-of.
            This confidential client application was itself called with a token which will be provided in the
            <paramref name="userAssertion">userAssertion</paramref> parameter.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        <remarks>You can also chain the following optional parameters:
            <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})" /></remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="AppTokenCache">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.ITokenCache AppTokenCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Identity.Client.ITokenCache AppTokenCache" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.ConfidentialClientApplication.AppTokenCache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AppTokenCache As ITokenCache" />
      <MemberSignature Language="F#" Value="member this.AppTokenCache : Microsoft.Identity.Client.ITokenCache" Usage="Microsoft.Identity.Client.ConfidentialClientApplication.AppTokenCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.Identity.Client.IConfidentialClientApplication.AppTokenCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.ITokenCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Application token cache. This case holds access tokens for the application. It's maintained
            and updated silently if needed when calling <see cref="M:Microsoft.Identity.Client.ConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})" /></summary>
        <value>To be added.</value>
        <remarks>On .NET Framework and .NET Core you can also customize the token cache serialization.
            See https://aka.ms/msal-net-token-cache-serialization. This is taken care of by MSAL.NET on other platforms
            </remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="AttemptRegionDiscovery">
      <MemberSignature Language="C#" Value="public const string AttemptRegionDiscovery;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string AttemptRegionDiscovery" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Identity.Client.ConfidentialClientApplication.AttemptRegionDiscovery" />
      <MemberSignature Language="VB.NET" Value="Public Const AttemptRegionDiscovery As String " />
      <MemberSignature Language="F#" Value="val mutable AttemptRegionDiscovery : string" Usage="Microsoft.Identity.Client.ConfidentialClientApplication.AttemptRegionDiscovery" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Instructs MSAL to try to auto discover the Azure region.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Certificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.ConfidentialClientApplication.Certificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Certificate As X509Certificate2" />
      <MemberSignature Language="F#" Value="member this.Certificate : System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="Microsoft.Identity.Client.ConfidentialClientApplication.Certificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The certificate used to create this <see cref="T:Microsoft.Identity.Client.ConfidentialClientApplication" />, if any.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAuthorizationRequestUrl">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder GetAuthorizationRequestUrl (System.Collections.Generic.IEnumerable&lt;string&gt; scopes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder GetAuthorizationRequestUrl(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.GetAuthorizationRequestUrl(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAuthorizationRequestUrl (scopes As IEnumerable(Of String)) As GetAuthorizationRequestUrlParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member GetAuthorizationRequestUrl : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder&#xA;override this.GetAuthorizationRequestUrl : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder" Usage="confidentialClientApplication.GetAuthorizationRequestUrl scopes" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IConfidentialClientApplication.GetAuthorizationRequestUrl(System.Collections.Generic.IEnumerable{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <summary>
            Computes the URL of the authorization request letting the user sign-in and consent to the application accessing specific scopes in
            the user's name. The URL targets the /authorize endpoint of the authority configured in the application.
            This override enables you to specify a login hint and extra query parameter.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request to get the
            URL of the STS authorization endpoint parametrized with the parameters</returns>
        <remarks>You can also chain the following optional parameters:
            <see cref="M:Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder.WithRedirectUri(System.String)" /><see cref="M:Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder.WithLoginHint(System.String)" /><see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})" /><see cref="M:Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder.WithExtraScopesToConsent(System.Collections.Generic.IEnumerable{System.String})" /></remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="InitiateLongRunningProcessInWebApi">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder InitiateLongRunningProcessInWebApi (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string userToken, ref string longRunningProcessSessionKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder InitiateLongRunningProcessInWebApi(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string userToken, string&amp; longRunningProcessSessionKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.InitiateLongRunningProcessInWebApi(System.Collections.Generic.IEnumerable{System.String},System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Function InitiateLongRunningProcessInWebApi (scopes As IEnumerable(Of String), userToken As String, ByRef longRunningProcessSessionKey As String) As AcquireTokenOnBehalfOfParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member InitiateLongRunningProcessInWebApi : seq&lt;string&gt; * string * string -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder&#xA;override this.InitiateLongRunningProcessInWebApi : seq&lt;string&gt; * string * string -&gt; Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder" Usage="confidentialClientApplication.InitiateLongRunningProcessInWebApi (scopes, userToken, longRunningProcessSessionKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.ILongRunningWebApi.InitiateLongRunningProcessInWebApi(System.Collections.Generic.IEnumerable{System.String},System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="userToken" Type="System.String" />
        <Parameter Name="longRunningProcessSessionKey" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="scopes">To be added.</param>
        <param name="userToken">To be added.</param>
        <param name="longRunningProcessSessionKey">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken">
      <MemberSignature Language="C#" Value="Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder IByRefreshToken.AcquireTokenByRefreshToken (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string refreshToken);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string refreshToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.Microsoft#Identity#Client#IByRefreshToken#AcquireTokenByRefreshToken(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Function AcquireTokenByRefreshToken (scopes As IEnumerable(Of String), refreshToken As String) As AcquireTokenByRefreshTokenParameterBuilder Implements IByRefreshToken.AcquireTokenByRefreshToken" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder&#xA;override this.Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder" Usage="confidentialClientApplication.Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken (scopes, refreshToken)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken(System.Collections.Generic.IEnumerable{System.String},System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="refreshToken" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">To be added.</param>
        <param name="refreshToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.Identity.Client.IByUsernameAndPassword.AcquireTokenByUsernamePassword">
      <MemberSignature Language="C#" Value="Microsoft.Identity.Client.AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder IByUsernameAndPassword.AcquireTokenByUsernamePassword (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string username, string password);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder Microsoft.Identity.Client.IByUsernameAndPassword.AcquireTokenByUsernamePassword(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string username, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.Microsoft#Identity#Client#IByUsernameAndPassword#AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Function AcquireTokenByUsernamePassword (scopes As IEnumerable(Of String), username As String, password As String) As AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder Implements IByUsernameAndPassword.AcquireTokenByUsernamePassword" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.Identity.Client.IByUsernameAndPassword.AcquireTokenByUsernamePassword : seq&lt;string&gt; * string * string -&gt; Microsoft.Identity.Client.AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder&#xA;override this.Microsoft.Identity.Client.IByUsernameAndPassword.AcquireTokenByUsernamePassword : seq&lt;string&gt; * string * string -&gt; Microsoft.Identity.Client.AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder" Usage="confidentialClientApplication.Microsoft.Identity.Client.IByUsernameAndPassword.AcquireTokenByUsernamePassword (scopes, username, password)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IByUsernameAndPassword.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">To be added.</param>
        <param name="username">To be added.</param>
        <param name="password">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="StopLongRunningProcessInWebApiAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; StopLongRunningProcessInWebApiAsync (string longRunningProcessSessionKey, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; StopLongRunningProcessInWebApiAsync(string longRunningProcessSessionKey, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.ConfidentialClientApplication.StopLongRunningProcessInWebApiAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function StopLongRunningProcessInWebApiAsync (longRunningProcessSessionKey As String, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Boolean)" />
      <MemberSignature Language="F#" Value="member this.StopLongRunningProcessInWebApiAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="confidentialClientApplication.StopLongRunningProcessInWebApiAsync (longRunningProcessSessionKey, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.77.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="longRunningProcessSessionKey" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="longRunningProcessSessionKey">OBO cache key used to remove the tokens.</param>
        <param name="cancellationToken">Cancellation token.</param>
        <summary>
            Stops an in-progress long-running on-behalf-of session by removing the tokens associated with the provided cache key.
            See <see href="https://aka.ms/msal-net-long-running-obo">Long-running OBO in MSAL.NET</see>.
            </summary>
        <returns>True if tokens are removed from the cache; false, otherwise.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="longRunningProcessSessionKey" /> is not set.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
