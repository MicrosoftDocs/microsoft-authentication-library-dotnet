<Type Name="PublicClientApplication" FullName="Microsoft.Identity.Client.PublicClientApplication">
  <TypeSignature Language="C#" Value="public sealed class PublicClientApplication : Microsoft.Identity.Client.ClientApplicationBase, Microsoft.Identity.Client.IByRefreshToken, Microsoft.Identity.Client.IPublicClientApplication" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PublicClientApplication extends Microsoft.Identity.Client.ClientApplicationBase implements class Microsoft.Identity.Client.IApplicationBase, class Microsoft.Identity.Client.IByRefreshToken, class Microsoft.Identity.Client.IClientApplicationBase, class Microsoft.Identity.Client.IPublicClientApplication" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Identity.Client.PublicClientApplication" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PublicClientApplication&#xA;Inherits ClientApplicationBase&#xA;Implements IByRefreshToken, IPublicClientApplication" />
  <TypeSignature Language="F#" Value="type PublicClientApplication = class&#xA;    inherit ClientApplicationBase&#xA;    interface IPublicClientApplication&#xA;    interface IClientApplicationBase&#xA;    interface IApplicationBase&#xA;    interface IByRefreshToken" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Identity.Client</AssemblyName>
    <AssemblyVersion>4.48.1.0</AssemblyVersion>
    <AssemblyVersion>4.49.1.0</AssemblyVersion>
    <AssemblyVersion>4.51.0.0</AssemblyVersion>
    <AssemblyVersion>4.52.0.0</AssemblyVersion>
    <AssemblyVersion>4.53.0.0</AssemblyVersion>
    <AssemblyVersion>4.54.0.0</AssemblyVersion>
    <AssemblyVersion>4.54.1.0</AssemblyVersion>
    <AssemblyVersion>4.55.0.0</AssemblyVersion>
    <AssemblyVersion>4.56.0.0</AssemblyVersion>
    <AssemblyVersion>4.57.0.0</AssemblyVersion>
    <AssemblyVersion>4.58.0.0</AssemblyVersion>
    <AssemblyVersion>4.58.1.0</AssemblyVersion>
    <AssemblyVersion>4.59.0.0</AssemblyVersion>
    <AssemblyVersion>4.60.0.0</AssemblyVersion>
    <AssemblyVersion>4.60.1.0</AssemblyVersion>
    <AssemblyVersion>4.60.2.0</AssemblyVersion>
    <AssemblyVersion>4.60.3.0</AssemblyVersion>
    <AssemblyVersion>4.61.0.0</AssemblyVersion>
    <AssemblyVersion>4.61.1.0</AssemblyVersion>
    <AssemblyVersion>4.61.3.0</AssemblyVersion>
    <AssemblyVersion>4.62.0.0</AssemblyVersion>
    <AssemblyVersion>4.63.0.0</AssemblyVersion>
    <AssemblyVersion>4.64.0.0</AssemblyVersion>
    <AssemblyVersion>4.64.1.0</AssemblyVersion>
    <AssemblyVersion>4.65.0.0</AssemblyVersion>
    <AssemblyVersion>4.66.0.0</AssemblyVersion>
    <AssemblyVersion>4.66.1.0</AssemblyVersion>
    <AssemblyVersion>4.66.2.0</AssemblyVersion>
    <AssemblyVersion>4.67.0.0</AssemblyVersion>
    <AssemblyVersion>4.67.1.0</AssemblyVersion>
    <AssemblyVersion>4.67.2.0</AssemblyVersion>
    <AssemblyVersion>4.68.0.0</AssemblyVersion>
    <AssemblyVersion>4.69.1.0</AssemblyVersion>
    <AssemblyVersion>4.70.0.0</AssemblyVersion>
    <AssemblyVersion>4.70.1.0</AssemblyVersion>
    <AssemblyVersion>4.70.2.0</AssemblyVersion>
    <AssemblyVersion>4.71.0.0</AssemblyVersion>
    <AssemblyVersion>4.71.1.0</AssemblyVersion>
    <AssemblyVersion>4.72.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.Identity.Client.ClientApplicationBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IApplicationBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IByRefreshToken</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IClientApplicationBase</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.Identity.Client.IPublicClientApplication</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
            Abstract class containing common API methods and properties.
            For details see https://aka.ms/msal-net-client-applications
            </summary>
    <remarks>
      <para>
            Unlike <see cref="T:Microsoft.Identity.Client.ConfidentialClientApplication" />, public clients are unable to hold configuration time secrets,
            and as a result have no client secret.
            </para>
      <para>
            The redirect URI needed for interactive authentication is automatically determined by the library. It does not need to be passed explicitly in the constructor. Depending
            on the authentication strategy (e.g., through the Web Authentication Manager, Authentication app, browser, etc.), different redirect URIs will be used by MSAL. Redirect URIs must always be configured in the Azure Active Directory blade in the Azure Portal.
            </para>
    </remarks>
    <example>
      <format type="text/markdown"><![CDATA[   
Here is an example of how to use `PublicClientApplication` with an [authentication broker](/entra/msal/dotnet/acquiring-tokens/desktop-mobile/wam) and [caching](/entra/msal/dotnet/how-to/token-cache-serialization?tabs=aspnetcore).
:::code language="csharp" source="~/../msal-dotnet-source/tests/devapps/NetCoreTestApp/Program.cs" range="78-110" highlight="1-4,16-17":::
 ]]></format>
    </example>
    <inheritdoc cref="T:Microsoft.Identity.Client.IPublicClientApplication" />
  </Docs>
  <Members>
    <Member MemberName="AcquireTokenByIntegratedWindowsAuth">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenByIntegratedWindowsAuthParameterBuilder AcquireTokenByIntegratedWindowsAuth (System.Collections.Generic.IEnumerable&lt;string&gt; scopes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenByIntegratedWindowsAuthParameterBuilder AcquireTokenByIntegratedWindowsAuth(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenByIntegratedWindowsAuth (scopes As IEnumerable(Of String)) As AcquireTokenByIntegratedWindowsAuthParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenByIntegratedWindowsAuth : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.AcquireTokenByIntegratedWindowsAuthParameterBuilder&#xA;override this.AcquireTokenByIntegratedWindowsAuth : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.AcquireTokenByIntegratedWindowsAuthParameterBuilder" Usage="publicClientApplication.AcquireTokenByIntegratedWindowsAuth scopes" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenByIntegratedWindowsAuthParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <summary>
            Non-interactive request to acquire a security token for the signed-in user in Windows,
            via Integrated Windows Authentication. See https://aka.ms/msal-net-iwa.
            The account used in this overrides is pulled from the operating system as the current user principal name.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        <remarks>
            You can also pass optional parameters by calling:
            <see cref="M:Microsoft.Identity.Client.AcquireTokenByIntegratedWindowsAuthParameterBuilder.WithUsername(System.String)" /> to pass the identifier
            of the user account for which to acquire a token with Integrated Windows authentication. This is generally in
            UserPrincipalName (UPN) format, e.g. john.doe@contoso.com. This is normally not needed, but some Windows administrators
            set policies preventing applications from looking-up the signed-in user in Windows, and in that case the username
            needs to be passed.
            You can also chain with
            <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})" /> to pass
            additional query parameters to the STS, and one of the overrides of <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithAuthority(System.String,System.Boolean)" />
            in order to override the default authority set at the application construction. Note that the overriding authority needs to be part
            of the known authorities added to the application construction.
            </remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenByUsernamePassword">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string username, System.Security.SecureString password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string username, class System.Security.SecureString password) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenByUsernamePassword (scopes As IEnumerable(Of String), username As String, password As SecureString) As AcquireTokenByUsernamePasswordParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenByUsernamePassword : seq&lt;string&gt; * string * System.Security.SecureString -&gt; Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder&#xA;override this.AcquireTokenByUsernamePassword : seq&lt;string&gt; * string * System.Security.SecureString -&gt; Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder" Usage="publicClientApplication.AcquireTokenByUsernamePassword (scopes, username, password)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Using SecureString is not recommended. Use AcquireTokenByUsernamePassword(IEnumerable&lt;string&gt; scopes, string username, string password) instead.", false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Using SecureString is not recommended. Use AcquireTokenByUsernamePassword(IEnumerable&lt;string&gt; scopes, string username, string password) instead.", false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="username">Identifier of the user application requests token on behalf.
            Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
        <param name="password">User password as a secure string.</param>
        <summary>
            Non-interactive request to acquire a security token from the authority, via Username/Password Authentication.
            See https://aka.ms/msal-net-up for details.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        <remarks>You can also pass optional parameters by chaining the builder with:
            <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})" /> to pass
            additional query parameters to the STS, and one of the overrides of <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithAuthority(System.String,System.Boolean)" />
            in order to override the default authority set at the application construction. Note that the overriding authority needs to be part
            of the known authorities added to the application construction.
            .NET no longer recommends using SecureString and MSAL puts the plaintext value of the password on the wire, as required by the OAuth protocol. See <see href="https://docs.microsoft.com/en-us/dotnet/api/system.security.securestring?view=net-6.0#remarks">SecureString documentation</see>.
            </remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenByUsernamePassword">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string username, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string username, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenByUsernamePassword (scopes As IEnumerable(Of String), username As String, password As String) As AcquireTokenByUsernamePasswordParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenByUsernamePassword : seq&lt;string&gt; * string * string -&gt; Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder&#xA;override this.AcquireTokenByUsernamePassword : seq&lt;string&gt; * string * string -&gt; Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder" Usage="publicClientApplication.AcquireTokenByUsernamePassword (scopes, username, password)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="username">Identifier of the user application requests token on behalf.
            Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
        <param name="password">User password as a string.</param>
        <summary>
            Non-interactive request to acquire a security token from the authority, via Username/Password Authentication.
            See https://aka.ms/msal-net-up for details.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        <remarks>You can also pass optional parameters by chaining the builder with:
            <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})" /> to pass
            additional query parameters to the Azure AD, and one of the overrides of <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithAuthority(System.String,System.Boolean)" />
            in order to override the default authority set at the application construction. Note that the overriding authority needs to be part
            of the known authorities added to the application construction.
            </remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenInteractive">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder AcquireTokenInteractive (System.Collections.Generic.IEnumerable&lt;string&gt; scopes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder AcquireTokenInteractive(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenInteractive (scopes As IEnumerable(Of String)) As AcquireTokenInteractiveParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenInteractive : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder&#xA;override this.AcquireTokenInteractive : seq&lt;string&gt; -&gt; Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder" Usage="publicClientApplication.AcquireTokenInteractive scopes" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <summary>
             Interactive request to acquire a token for the specified scopes. The interactive window will be parented to the specified
             window. The user will be required to select an account.
             </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        <remarks>The user will be signed-in interactively if needed,
             and will consent to scopes and do multi-factor authentication if such a policy was enabled in the Azure AD tenant.
            
             You can also pass optional parameters by calling:
                     
             <see cref="M:Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder.WithPrompt(Microsoft.Identity.Client.Prompt)" /> to specify the user experience
             when signing-in, <see cref="M:Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder.WithUseEmbeddedWebView(System.Boolean)" /> to specify
             if you want to use the embedded web browser or the system default browser,
             <see cref="M:Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder.WithSystemWebViewOptions(Microsoft.Identity.Client.SystemWebViewOptions)" /> to configure
             the user experience when using the Default browser,
             <see cref="M:Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder.WithAccount(Microsoft.Identity.Client.IAccount)" /> or <see cref="M:Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder.WithLoginHint(System.String)" />
             to prevent the select account dialog from appearing in the case you want to sign-in a specific account,
             <see cref="M:Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder.WithExtraScopesToConsent(System.Collections.Generic.IEnumerable{System.String})" /> if you want to let the
             user pre-consent to additional scopes (which won't be returned in the access token),
             <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})" /> to pass
             additional query parameters to the STS, and one of the overrides of <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithAuthority(System.String,System.Boolean)" />
             in order to override the default authority set at the application construction. Note that the overriding authority needs to be part
             of the known authorities added to the application construction.
             </remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="AcquireTokenWithDeviceCode">
      <MemberSignature Language="C#" Value="public Microsoft.Identity.Client.AcquireTokenWithDeviceCodeParameterBuilder AcquireTokenWithDeviceCode (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, Func&lt;Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task&gt; deviceCodeResultCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenWithDeviceCodeParameterBuilder AcquireTokenWithDeviceCode(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, class System.Func`2&lt;class Microsoft.Identity.Client.DeviceCodeResult, class System.Threading.Tasks.Task&gt; deviceCodeResultCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenWithDeviceCode(System.Collections.Generic.IEnumerable{System.String},System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function AcquireTokenWithDeviceCode (scopes As IEnumerable(Of String), deviceCodeResultCallback As Func(Of DeviceCodeResult, Task)) As AcquireTokenWithDeviceCodeParameterBuilder" />
      <MemberSignature Language="F#" Value="abstract member AcquireTokenWithDeviceCode : seq&lt;string&gt; * Func&lt;Microsoft.Identity.Client.DeviceCodeResult, System.Threading.Tasks.Task&gt; -&gt; Microsoft.Identity.Client.AcquireTokenWithDeviceCodeParameterBuilder&#xA;override this.AcquireTokenWithDeviceCode : seq&lt;string&gt; * Func&lt;Microsoft.Identity.Client.DeviceCodeResult, System.Threading.Tasks.Task&gt; -&gt; Microsoft.Identity.Client.AcquireTokenWithDeviceCodeParameterBuilder" Usage="publicClientApplication.AcquireTokenWithDeviceCode (scopes, deviceCodeResultCallback)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenWithDeviceCode(System.Collections.Generic.IEnumerable{System.String},System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenWithDeviceCodeParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="deviceCodeResultCallback" Type="System.Func&lt;Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="scopes">Scopes requested to access a protected API</param>
        <param name="deviceCodeResultCallback">Callback containing information to show the user about how to authenticate and enter the device code.</param>
        <summary>
            Acquires a security token on a device without a web browser, by letting the user authenticate on
            another device. This is done in two steps:
            <list type="bullet"><item><description>The method first acquires a device code from the authority and returns it to the caller via
            the <paramref name="deviceCodeResultCallback" />. This callback takes care of interacting with the user
            to direct them to authenticate (to a specific URL, with a code)</description></item><item><description>The method then proceeds to poll for the security
            token which is granted upon successful login by the user based on the device code information</description></item></list>
            See https://aka.ms/msal-device-code-flow.
            </summary>
        <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        <remarks>
            You can also pass optional parameters by calling:
            <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})" /> to pass
            additional query parameters to the STS, and one of the overrides of <see cref="M:Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithAuthority(System.String,System.Boolean)" />
            in order to override the default authority set at the application construction. Note that the overriding authority needs to be part
            of the known authorities added to the application construction.
            </remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="IsBrokerAvailable">
      <MemberSignature Language="C#" Value="public bool IsBrokerAvailable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBrokerAvailable() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.PublicClientApplication.IsBrokerAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Function IsBrokerAvailable () As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsBrokerAvailable : unit -&gt; bool" Usage="publicClientApplication.IsBrokerAvailable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns <c>true</c> if an authentication broker can be used.
            This method is only needed for mobile scenarios which support Mobile Application Management (MAM). In other cases, use <c>WithBroker</c>, which will fall back to use a browser if an authentication broker is unavailable.
            </summary>
        <returns>To be added.</returns>
        <remarks>
          <list type="bullet">
            <item>
              <description>On Windows, the broker (WAM) can be used on Windows 10 and is always installed. See https://aka.ms/msal-net-wam </description>
            </item>
            <item>
              <description>On Mac, Linux, and older versions of Windows a broker is not available.</description>
            </item>
            <item>
              <description>In .NET 8 apps, target <c>net8.0-windows10.0.17763.0</c> for all Windows versions and target <c>net8.0</c> for Linux and Mac.</description>
            </item>
            <item>
              <description>In .NET classic or .NET Core 3.1 apps, install Microsoft.Identity.Client.Desktop first and call <c>WithDesktopFeatures()</c>.</description>
            </item>
            <item>
              <description>In mobile apps, the device must be Intune joined and Authenticator or Company Portal must be installed. See https://aka.ms/msal-brokers </description>
            </item>
          </list>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmbeddedWebViewAvailable">
      <MemberSignature Language="C#" Value="public bool IsEmbeddedWebViewAvailable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEmbeddedWebViewAvailable() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.PublicClientApplication.IsEmbeddedWebViewAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEmbeddedWebViewAvailable () As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsEmbeddedWebViewAvailable : unit -&gt; bool" Usage="publicClientApplication.IsEmbeddedWebViewAvailable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns <c>true</c> if MSAL can use an embedded web view (web browser).
            </summary>
        <returns>To be added.</returns>
        <remarks>
            All .NET Framework applications will use the legacy web view. .NET 6 and .NET Core applications must use the <see href="https://www.nuget.org/packages/Microsoft.Identity.Client.Desktop">Microsoft.Identity.Client.Desktop</see> package with WebView2. .NET 6 for Windows comes with WebView2 by default.
            WebView2 UI is only shown for non-AAD authorities.
            Refer to <see href="https://aka.ms/msal-net-webview2">our documentation</see> for additional details.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsProofOfPossessionSupportedByClient">
      <MemberSignature Language="C#" Value="public bool IsProofOfPossessionSupportedByClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsProofOfPossessionSupportedByClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.PublicClientApplication.IsProofOfPossessionSupportedByClient" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProofOfPossessionSupportedByClient () As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsProofOfPossessionSupportedByClient : unit -&gt; bool" Usage="publicClientApplication.IsProofOfPossessionSupportedByClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Used to determine if the currently available broker is able to perform Proof-of-Possession.
            </summary>
        <returns>Boolean indicating if Proof-of-Possession is supported</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSystemWebViewAvailable">
      <MemberSignature Language="C#" Value="public bool IsSystemWebViewAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSystemWebViewAvailable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.PublicClientApplication.IsSystemWebViewAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSystemWebViewAvailable As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsSystemWebViewAvailable : bool" Usage="Microsoft.Identity.Client.PublicClientApplication.IsSystemWebViewAvailable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.Identity.Client.IPublicClientApplication.IsSystemWebViewAvailable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns true if MSAL can use a system browser.
            </summary>
        <value>To be added.</value>
        <remarks>
            On Windows, Mac and Linux a system browser can always be used, except in cases where there is no UI, e.g. SSH connection.
            On Android, the browser must support tabs.
            </remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="IsUserInteractive">
      <MemberSignature Language="C#" Value="public bool IsUserInteractive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsUserInteractive() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.PublicClientApplication.IsUserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Function IsUserInteractive () As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsUserInteractive : unit -&gt; bool" Usage="publicClientApplication.IsUserInteractive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns <c>false</c> when the application runs in headless mode (e.g., when SSH-d into a Linux machine).
            Browsers (web views) and brokers cannot be used if there is no UI support. For those scenarios, use <see cref="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenWithDeviceCode(System.Collections.Generic.IEnumerable{System.String},System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken">
      <MemberSignature Language="C#" Value="Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder IByRefreshToken.AcquireTokenByRefreshToken (System.Collections.Generic.IEnumerable&lt;string&gt; scopes, string refreshToken);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken(class System.Collections.Generic.IEnumerable`1&lt;string&gt; scopes, string refreshToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Identity.Client.PublicClientApplication.Microsoft#Identity#Client#IByRefreshToken#AcquireTokenByRefreshToken(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Function AcquireTokenByRefreshToken (scopes As IEnumerable(Of String), refreshToken As String) As AcquireTokenByRefreshTokenParameterBuilder Implements IByRefreshToken.AcquireTokenByRefreshToken" />
      <MemberSignature Language="F#" Value="abstract member Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder&#xA;override this.Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken : seq&lt;string&gt; * string -&gt; Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder" Usage="publicClientApplication.Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken (scopes, refreshToken)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken(System.Collections.Generic.IEnumerable{System.String},System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopes" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="refreshToken" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scopes">To be added.</param>
        <param name="refreshToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="OperatingSystemAccount">
      <MemberSignature Language="C#" Value="public static Microsoft.Identity.Client.IAccount OperatingSystemAccount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Identity.Client.IAccount OperatingSystemAccount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Identity.Client.PublicClientApplication.OperatingSystemAccount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OperatingSystemAccount As IAccount" />
      <MemberSignature Language="F#" Value="static member OperatingSystemAccount : Microsoft.Identity.Client.IAccount" Usage="Microsoft.Identity.Client.PublicClientApplication.OperatingSystemAccount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Identity.Client</AssemblyName>
        <AssemblyVersion>4.72.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Identity.Client.IAccount</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            A special account value that indicates that the current operating system account should be used 
            to log the user in. Not all operating systems and authentication flows support this concept, in which 
            case calling <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)" /> will throw an <see cref="T:Microsoft.Identity.Client.MsalUiRequiredException" />. 
            </summary>
        <value>To be added.</value>
        <remarks>
            Currently only the Windows broker is able to login with the current operating system user. For additional details, see <see href="https://aka.ms/msal-net-wam">the documentation on the Windows broker</see>.
            </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
